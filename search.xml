<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>flink学习笔记04-flink高级API</title>
      <link href="/post/74803824.html"/>
      <url>/post/74803824.html</url>
      
        <content type="html"><![CDATA[<h2 id="Flink四大基石"><a href="#Flink四大基石" class="headerlink" title="Flink四大基石"></a>Flink四大基石</h2><p>Flink之所以能这么流行，离不开它最重要的四个基石：Checkpoint、State、Time、Window。</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210213204052.png"></p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p>这是Flink最重要的一个特性。</p><ul><li><p>Flink基于Chandy-Lamport算法实现了一个分布式的一致性的快照，从而提供了一致性的语义。</p></li><li><p>Chandy-Lamport算法实际上在1985年的时候已经被提出来，但并没有被很广泛的应用，而Flink则把这个算法发扬光大了。</p></li><li><p>Spark最近在实现Continue streaming，Continue streaming的目的是为了降低处理的延时，其也需要提供这种一致性的语义，最终也采用了Chandy-Lamport这个算法，说明Chandy-Lamport算法在业界得到了一定的肯定。</p></li></ul><blockquote><p>分布式快照算法: <a href="https://zhuanlan.zhihu.com/p/53482103">https://zhuanlan.zhihu.com/p/53482103</a></p></blockquote><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>提供了一致性的语义之后，Flink为了让用户在编程时能够更轻松、更容易地去管理状态，还提供了一套非常简单明了的State API，包括ValueState、ListState、MapState，BroadcastState。</p><h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>除此之外，Flink还实现了Watermark的机制，能够支持基于事件的时间的处理，能够容忍迟到&#x2F;乱序的数据。</p><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>另外流计算中一般在对流数据进行操作之前都会先进行开窗，即基于一个什么样的窗口上做这个计算。Flink提供了开箱即用的各种窗口，比如滑动窗口、滚动窗口、会话窗口以及非常灵活的自定义的窗口。</p><h2 id="Flink-Window操作"><a href="#Flink-Window操作" class="headerlink" title="Flink-Window操作"></a>Flink-Window操作</h2><h3 id="为什么需要Window"><a href="#为什么需要Window" class="headerlink" title="为什么需要Window"></a>为什么需要Window</h3><p>在流处理应用中，数据是连续不断的，有时我们需要做一些聚合类的处理，例如：在过去的1分钟内有多少用户点击了我们的网页。</p><p>在这种情况下，我们必须定义一个窗口(window)，用来收集最近1分钟内的数据，并对这个窗口内的数据进行计算。</p><h3 id="Window的分类"><a href="#Window的分类" class="headerlink" title="Window的分类"></a>Window的分类</h3><h4 id="按照time和count分类"><a href="#按照time和count分类" class="headerlink" title="按照time和count分类"></a>按照time和count分类</h4><ul><li>time-window:时间窗口:根据时间划分窗口,如:每xx分钟统计最近xx分钟的数据</li><li>count-window:数量窗口:根据数量划分窗口,如:每xx个数据统计最近xx个数据</li></ul><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210213182442.png"></p><h4 id="按照slide和size分类"><a href="#按照slide和size分类" class="headerlink" title="按照slide和size分类"></a>按照slide和size分类</h4><p>窗口有两个重要的属性: 窗口大小<strong>size</strong>和滑动间隔<strong>slide</strong>,根据它们的大小关系可分为:</p><ul><li><p>tumbling-window:滚动窗口:size&#x3D;slide,如:每隔10s统计最近10s的数据</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210213182855.png"></p></li><li><p>sliding-window:滑动窗口:size&gt;slide,如:每隔5s统计最近10s的数据</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210213182920.png"></p></li></ul><p><strong>注意</strong>:当size&lt;slide的时候,如每隔15s统计最近10s的数据,那么中间5s的数据会丢失,所有开发中不用</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>按照上面窗口的分类方式进行组合,可以得出如下的窗口:</p><ul><li>基于时间的滚动窗口tumbling-time-window–用的较多</li><li>基于时间的滑动窗口sliding-time-window–用的较多</li><li>基于数量的滚动窗口tumbling-count-window–用的较少</li><li>基于数量的滑动窗口sliding-count-window–用的较少</li></ul><p><strong>注意</strong>:Flink还支持一个特殊的窗口:Session会话窗口,需要设置一个会话超时时间,如30s,则表示30s内没有数据到来,则触发上个窗口的计算</p><h3 id="Window的API"><a href="#Window的API" class="headerlink" title="Window的API"></a>Window的API</h3><h4 id="window和windowAll"><a href="#window和windowAll" class="headerlink" title="window和windowAll"></a>window和windowAll</h4><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210213183548.png"></p><ul><li>使用keyby的流,应该使用window方法</li><li>未使用keyby的流,应该调用windowAll方法</li></ul><h4 id="WindowAssigner"><a href="#WindowAssigner" class="headerlink" title="WindowAssigner"></a>WindowAssigner</h4><p>window&#x2F;windowAll 方法接收的输入是一个 WindowAssigner， WindowAssigner 负责将每条输入的数据分发到正确的 window 中，Flink提供了很多各种场景用的WindowAssigner：</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210213184025.png"></p><p>如果需要自己定制数据分发策略，则可以实现一个 class，继承自 WindowAssigner。</p><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><h4 id="基于时间的滚动和滑动窗口"><a href="#基于时间的滚动和滑动窗口" class="headerlink" title="基于时间的滚动和滑动窗口"></a>基于时间的滚动和滑动窗口</h4><ul><li><p>需求1:每5秒钟统计一次，最近5秒钟内，各个路口通过红绿灯汽车的数量–基于时间的滚动窗口</p></li><li><p>需求2:每5秒钟统计一次，最近10秒钟内，各个路口通过红绿灯汽车的数量–基于时间的滑动窗口</p></li></ul><p>示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowDemo01_TimeWindow</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.env</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//2.Source</span></span><br><span class="line">        DataStreamSource&lt;String&gt; socketDS = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.Transformation</span></span><br><span class="line">        <span class="comment">//将9,3转为CartInfo(9,3)</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; cartInfoDS = socketDS.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, CartInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CartInfo <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                String[] arr = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CartInfo</span>(arr[<span class="number">0</span>], Integer.parseInt(arr[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分组</span></span><br><span class="line">        <span class="comment">//KeyedStream&lt;CartInfo, Tuple&gt; keyedDS = cartInfoDS.keyBy(&quot;sensorId&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// * 需求1:每5秒钟统计一次，最近5秒钟内，各个路口/信号灯通过红绿灯汽车的数量--基于时间的滚动窗口</span></span><br><span class="line">        <span class="comment">//timeWindow(Time size窗口大小, Time slide滑动间隔)</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; result1 = cartInfoDS</span><br><span class="line">                .keyBy(CartInfo::getSensorId)</span><br><span class="line">                <span class="comment">//.timeWindow(Time.seconds(5))//当size==slide,可以只写一个</span></span><br><span class="line">                <span class="comment">//.timeWindow(Time.seconds(5), Time.seconds(5))</span></span><br><span class="line">                .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">                .sum(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// * 需求2:每5秒钟统计一次，最近10秒钟内，各个路口/信号灯通过红绿灯汽车的数量--基于时间的滑动窗口</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; result2 = cartInfoDS</span><br><span class="line">                .keyBy(CartInfo::getSensorId)</span><br><span class="line">                <span class="comment">//.timeWindow(Time.seconds(10), Time.seconds(5))</span></span><br><span class="line">                .window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">                .sum(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.Sink</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1,5</span></span><br><span class="line"><span class="comment">2,5</span></span><br><span class="line"><span class="comment">3,5</span></span><br><span class="line"><span class="comment">4,5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">//result1.print();</span></span><br><span class="line">        result2.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.execute</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CartInfo</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String sensorId;<span class="comment">//信号灯id</span></span><br><span class="line">        <span class="keyword">private</span> Integer count;<span class="comment">//通过该信号灯的车的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于数量的滚动和滑动窗口"><a href="#基于数量的滚动和滑动窗口" class="headerlink" title="基于数量的滚动和滑动窗口"></a>基于数量的滚动和滑动窗口</h4><ul><li><p>需求1:统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现5次进行统计–基于数量的滚动窗口</p></li><li><p>需求2:统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现3次进行统计–基于数量的滑动窗口</p></li></ul><p>示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowDemo02_CountWindow</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.env</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//2.Source</span></span><br><span class="line">        DataStreamSource&lt;String&gt; socketDS = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.Transformation</span></span><br><span class="line">        <span class="comment">//将9,3转为CartInfo(9,3)</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; cartInfoDS = socketDS.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, CartInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CartInfo <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                String[] arr = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CartInfo</span>(arr[<span class="number">0</span>], Integer.parseInt(arr[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分组</span></span><br><span class="line">        <span class="comment">//KeyedStream&lt;CartInfo, Tuple&gt; keyedDS = cartInfoDS.keyBy(&quot;sensorId&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// * 需求1:统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现5次进行统计--基于数量的滚动窗口</span></span><br><span class="line">        <span class="comment">//countWindow(long size, long slide)</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; result1 = cartInfoDS</span><br><span class="line">                .keyBy(CartInfo::getSensorId)</span><br><span class="line">                <span class="comment">//.countWindow(5L, 5L)</span></span><br><span class="line">                .countWindow( <span class="number">5L</span>)</span><br><span class="line">                .sum(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// * 需求2:统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现3次进行统计--基于数量的滑动窗口</span></span><br><span class="line">        <span class="comment">//countWindow(long size, long slide)</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; result2 = cartInfoDS</span><br><span class="line">                .keyBy(CartInfo::getSensorId)</span><br><span class="line">                .countWindow(<span class="number">5L</span>, <span class="number">3L</span>)</span><br><span class="line">                .sum(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.Sink</span></span><br><span class="line">        <span class="comment">//result1.print();</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">2,1</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result2.print();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">2,1</span></span><br><span class="line"><span class="comment">1,1</span></span><br><span class="line"><span class="comment">2,1</span></span><br><span class="line"><span class="comment">3,1</span></span><br><span class="line"><span class="comment">4,1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.execute</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CartInfo</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String sensorId;<span class="comment">//信号灯id</span></span><br><span class="line">        <span class="keyword">private</span> Integer count;<span class="comment">//通过该信号灯的车的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="会话窗口"><a href="#会话窗口" class="headerlink" title="会话窗口"></a>会话窗口</h4><ul><li>设置会话超时时间为10s,10s内没有数据到来,则触发上个窗口的计算</li></ul><p>示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowDemo03_SessionWindow</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.env</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//2.Source</span></span><br><span class="line">        DataStreamSource&lt;String&gt; socketDS = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.Transformation</span></span><br><span class="line">        <span class="comment">//将9,3转为CartInfo(9,3)</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; cartInfoDS = socketDS.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, CartInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CartInfo <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                String[] arr = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CartInfo</span>(arr[<span class="number">0</span>], Integer.parseInt(arr[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求:设置会话超时时间为10s,10s内没有数据到来,则触发上个窗口的计算(前提是上一个窗口得有数据!)</span></span><br><span class="line">        SingleOutputStreamOperator&lt;CartInfo&gt; result = cartInfoDS.keyBy(CartInfo::getSensorId)</span><br><span class="line">                .window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">                .sum(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.Sink</span></span><br><span class="line">        result.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.execute</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CartInfo</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String sensorId;<span class="comment">//信号灯id</span></span><br><span class="line">        <span class="keyword">private</span> Integer count;<span class="comment">//通过该信号灯的车的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flink-Time与Watermaker"><a href="#Flink-Time与Watermaker" class="headerlink" title="Flink-Time与Watermaker"></a>Flink-Time与Watermaker</h2><h3 id="Time分类"><a href="#Time分类" class="headerlink" title="Time分类"></a>Time分类</h3><p>在Flink的流式处理中，会涉及到时间的不同概念，如下图所示：</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210213205430.png"></p><ul><li>事件时间EventTime:   事件真真正正发生产生的时间</li><li>摄入时间IngestionTime:    事件到达Flink的时间</li><li>处理时间ProcessingTime:  事件真正被处理&#x2F;计算的时间</li></ul><h3 id="Watermaker水印机制-x2F-水位线机制"><a href="#Watermaker水印机制-x2F-水位线机制" class="headerlink" title="Watermaker水印机制&#x2F;水位线机制"></a>Watermaker水印机制&#x2F;水位线机制</h3><p>Watermaker就是给数据再额外的加的一个时间列，Watermaker &#x3D; 当前窗口的最大的事件时间  -  最大允许的延迟时间或乱序时间</p><h4 id="图解watermaker"><a href="#图解watermaker" class="headerlink" title="图解watermaker"></a>图解watermaker</h4><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215211800.png"></p><h4 id="watermaker案例演示"><a href="#watermaker案例演示" class="headerlink" title="watermaker案例演示"></a>watermaker案例演示</h4><ul><li><p>需求</p><ul><li><p>有订单数据,格式为: (订单ID，用户ID，时间戳&#x2F;事件时间，订单金额)</p></li><li><p>要求每隔5s,计算5秒内，每个用户的订单总金额</p></li><li><p>并添加Watermaker来解决一定程度上的数据延迟和数据乱序问题。</p></li></ul></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatermakerDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.env</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//2.Source</span></span><br><span class="line">        <span class="comment">//模拟实时订单数据(数据有延迟和乱序)</span></span><br><span class="line">        DataStream&lt;Order&gt; orderDS = env.addSource(<span class="keyword">new</span> <span class="title class_">SourceFunction</span>&lt;Order&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;Order&gt; ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> random.nextInt(<span class="number">3</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">//模拟数据延迟和乱序!</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">eventTime</span> <span class="operator">=</span> System.currentTimeMillis() - random.nextInt(<span class="number">5</span>) * <span class="number">1000</span>;</span><br><span class="line">                    ctx.collect(<span class="keyword">new</span> <span class="title class_">Order</span>(orderId, userId, money, eventTime));</span><br><span class="line"></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.Transformation</span></span><br><span class="line">        <span class="comment">//-告诉Flink要基于事件时间来计算!</span></span><br><span class="line">        <span class="comment">//env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);//新版本默认就是EventTime</span></span><br><span class="line">        <span class="comment">//-告诉Flnk数据中的哪一列是事件时间,因为Watermaker = 当前最大的事件时间 - 最大允许的延迟时间或乱序时间</span></span><br><span class="line">        <span class="comment">/*DataStream&lt;Order&gt; watermakerDS = orderDS.assignTimestampsAndWatermarks(</span></span><br><span class="line"><span class="comment">                new BoundedOutOfOrdernessTimestampExtractor&lt;Order&gt;(Time.seconds(3)) &#123;//最大允许的延迟时间或乱序时间</span></span><br><span class="line"><span class="comment">                    @Override</span></span><br><span class="line"><span class="comment">                    public long extractTimestamp(Order element) &#123;</span></span><br><span class="line"><span class="comment">                        return element.eventTime;</span></span><br><span class="line"><span class="comment">                        //指定事件时间是哪一列,Flink底层会自动计算:</span></span><br><span class="line"><span class="comment">                        //Watermaker = 当前最大的事件时间 - 最大允许的延迟时间或乱序时间</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">        DataStream&lt;Order&gt; watermakerDS = orderDS</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy.&lt;Order&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">                                .withTimestampAssigner((event, timestamp) -&gt; event.getEventTime())</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码走到这里,就已经被添加上Watermaker了!接下来就可以进行窗口计算了</span></span><br><span class="line">        <span class="comment">//要求每隔5s,计算5秒内(基于时间的滚动窗口)，每个用户的订单总金额</span></span><br><span class="line">        DataStream&lt;Order&gt; result = watermakerDS</span><br><span class="line">                .keyBy(Order::getUserId)</span><br><span class="line">                <span class="comment">//.timeWindow(Time.seconds(5), Time.seconds(5))</span></span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">                .sum(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.Sink</span></span><br><span class="line">        result.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.execute</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String orderId;</span><br><span class="line">        <span class="keyword">private</span> Integer userId;</span><br><span class="line">        <span class="keyword">private</span> Integer money;</span><br><span class="line">        <span class="keyword">private</span> Long eventTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Flink-状态管理"><a href="#Flink-状态管理" class="headerlink" title="Flink-状态管理"></a>Flink-状态管理</h2><h3 id="无状态计算和有状态计算"><a href="#无状态计算和有状态计算" class="headerlink" title="无状态计算和有状态计算"></a>无状态计算和有状态计算</h3><h4 id="无状态计算"><a href="#无状态计算" class="headerlink" title="无状态计算"></a>无状态计算</h4><ul><li><p>不需要考虑历史数据</p></li><li><p>相同的输入得到相同的输出就是无状态计算, 如map&#x2F;flatMap&#x2F;filter….</p></li></ul><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215213048.png"></p><h4 id="有状态计算"><a href="#有状态计算" class="headerlink" title="有状态计算"></a>有状态计算</h4><ul><li><p>需要考虑历史数据</p></li><li><p>相同的输入得到不同的输出&#x2F;不一定得到相同的输出,就是有状态计算,如:sum&#x2F;reduce</p></li></ul><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215213133.png"></p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215213236.png"></p><h3 id="状态的分类"><a href="#状态的分类" class="headerlink" title="状态的分类"></a>状态的分类</h3><h4 id="Managed-State-amp-Raw-State"><a href="#Managed-State-amp-Raw-State" class="headerlink" title="Managed State &amp; Raw State"></a>Managed State &amp; Raw State</h4><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215213428.png"></p><p>从Flink是否接管角度:可以分为Managed State(托管状态) ,Raw State(原始状态),两者的区别如下：</p><ul><li>从状态管理方式的方式来说，Managed State 由 Flink Runtime 管理，自动存储，自动恢复，在内存管理上有优化；而 RawState 需要用户自己管理，需要自己序列化，Flink 不知道 State 中存入的数据是什么结构，只有用户自己知道，需要最终序列化为可存储的数据结构。</li><li>从状态数据结构来说，Managed State 支持已知的数据结构，如 Value、List、Map 等。而 Raw State只支持字节数组 ，所有状态都要转换为二进制字节数组才可以。</li><li>从推荐使用场景来说，Managed State 大多数情况下均可使用，而 Raw State 是当 Managed State 不够用时，比如需要自定义 Operator 时，才会使用 Raw State。</li><li>在实际生产中，都只<strong>推荐使用ManagedState</strong></li></ul><h4 id="Keyed-State-amp-Operator-State"><a href="#Keyed-State-amp-Operator-State" class="headerlink" title="Keyed State &amp; Operator State"></a>Keyed State &amp; Operator State</h4><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215230854.png"></p><p>Managed State 分为两种，Keyed State 和 Operator State (Raw State都是Operator State)</p><ul><li><p>Keyed State</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215231015.png"></p></li></ul><p>在Flink Stream模型中，Datastream 经过 keyBy 的操作可以变为 KeyedStream。</p><p>Keyed State是基于KeyedStream上的状态。这个状态是跟特定的key绑定的，对KeyedStream流上的每一个key，都对应一个state，如stream.keyBy(…)</p><p>KeyBy之后的State,可以理解为分区过的State，每个并行keyed Operator的每个实例的每个key都有一个Keyed State，即&lt;parallel-operator-instance,key&gt;就是一个唯一的状态，由于每个key属于一个keyed Operator的并行实例，因此我们将其简单的理解为&lt;operator,key&gt;</p><ul><li><p>Operator State</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215231216.png"></p><p>这里的fromElements会调用FromElementsFunction的类，其中就使用了类型为 list state 的 operator state</p><p>Operator State又称为 non-keyed state，与Key无关的State，每一个 operator state 都仅与一个 operator 的实例绑定。</p><p>Operator State 可以用于所有算子，但一般常用于 Source</p></li></ul><h3 id="State代码示例"><a href="#State代码示例" class="headerlink" title="State代码示例"></a>State代码示例</h3><h4 id="Keyed-State"><a href="#Keyed-State" class="headerlink" title="Keyed State"></a>Keyed State</h4><p>下图就 word count 的 sum 所使用的StreamGroupedReduce类为例讲解了如何在代码中使用 keyed state：</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215232851.png"></p><blockquote><p>官网代码示例:<a href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/state/state.html#using-managed-keyed-state">https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/state/state.html#using-managed-keyed-state</a></p></blockquote><ul><li><p>使用KeyState中的ValueState获取数据中的最大值(实际中直接使用maxBy即可)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateDemo01_KeyedState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.env</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);<span class="comment">//方便观察</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.Source</span></span><br><span class="line">        DataStreamSource&lt;Tuple2&lt;String, Long&gt;&gt; tupleDS = env.fromElements(</span><br><span class="line">                Tuple2.of(<span class="string">&quot;北京&quot;</span>, <span class="number">1L</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;上海&quot;</span>, <span class="number">2L</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;北京&quot;</span>, <span class="number">6L</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;上海&quot;</span>, <span class="number">8L</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;北京&quot;</span>, <span class="number">3L</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;上海&quot;</span>, <span class="number">4L</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.Transformation</span></span><br><span class="line">        <span class="comment">//使用KeyState中的ValueState获取流数据中的最大值(实际中直接使用maxBy即可)</span></span><br><span class="line">        <span class="comment">//实现方式1:直接使用maxBy--开发中使用该方式即可</span></span><br><span class="line">        <span class="comment">//min只会求出最小的那个字段,其他的字段不管</span></span><br><span class="line">        <span class="comment">//minBy会求出最小的那个字段和对应的其他的字段</span></span><br><span class="line">        <span class="comment">//max只会求出最大的那个字段,其他的字段不管</span></span><br><span class="line">        <span class="comment">//maxBy会求出最大的那个字段和对应的其他的字段</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; result = tupleDS.keyBy(t -&gt; t.f0)</span><br><span class="line">                .maxBy(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现方式2:使用KeyState中的ValueState---学习测试时使用,或者后续项目中/实际开发中遇到复杂的Flink没有实现的逻辑,才用该方式!</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Long, Long&gt;&gt; result2 = tupleDS.keyBy(t -&gt; t.f0)</span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">RichMapFunction</span>&lt;Tuple2&lt;String, Long&gt;, Tuple3&lt;String, Long, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="comment">//-1.定义状态用来存储最大值</span></span><br><span class="line">                    <span class="keyword">private</span> ValueState&lt;Long&gt; maxValueState = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">//-2.定义状态描述符:描述状态的名称和里面的数据类型</span></span><br><span class="line">                        <span class="type">ValueStateDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>(<span class="string">&quot;maxValueState&quot;</span>, Long.class);</span><br><span class="line">                        <span class="comment">//-3.根据状态描述符初始化状态</span></span><br><span class="line">                        maxValueState = getRuntimeContext().getState(descriptor);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Tuple3&lt;String, Long, Long&gt; <span class="title function_">map</span><span class="params">(Tuple2&lt;String, Long&gt; value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">//-4.使用State,取出State中的最大值/历史最大值</span></span><br><span class="line">                        <span class="type">Long</span> <span class="variable">historyMaxValue</span> <span class="operator">=</span> maxValueState.value();</span><br><span class="line">                        <span class="type">Long</span> <span class="variable">currentValue</span> <span class="operator">=</span> value.f1;</span><br><span class="line">                        <span class="keyword">if</span> (historyMaxValue == <span class="literal">null</span> || currentValue &gt; historyMaxValue) &#123;</span><br><span class="line">                            <span class="comment">//5-更新状态,把当前的作为新的最大值存到状态中</span></span><br><span class="line">                            maxValueState.update(currentValue);</span><br><span class="line">                            <span class="keyword">return</span> Tuple3.of(value.f0, currentValue, currentValue);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> Tuple3.of(value.f0, currentValue, historyMaxValue);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.Sink</span></span><br><span class="line">        <span class="comment">//result.print();</span></span><br><span class="line">        result2.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.execute</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="Operator-State"><a href="#Operator-State" class="headerlink" title="Operator State"></a>Operator State</h4><p>下图对 word count 示例中的FromElementsFunction类进行详解并分享如何在代码中使用 operator state：</p><p><img src="https://dik111-1258101294.cos.ap-guangzhou.myqcloud.com/20210215233329.png"></p><blockquote><p>官网代码示例:<a href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/state/state.html#using-managed-operator-state">https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/state/state.html#using-managed-operator-state</a></p></blockquote><ul><li><p>使用ListState存储offset模拟Kafka的offset维护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc</span></span><br><span class="line"><span class="comment"> * 需求:</span></span><br><span class="line"><span class="comment"> * 使用OperatorState支持的数据结构ListState存储offset信息, 模拟Kafka的offset维护,</span></span><br><span class="line"><span class="comment"> * 其实就是FlinkKafkaConsumer底层对应offset的维护!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateDemo02_OperatorState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.env</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//先直接使用下面的代码设置Checkpoint时间间隔和磁盘路径以及代码遇到异常后的重启策略,下午会学</span></span><br><span class="line">        env.enableCheckpointing(<span class="number">1000</span>);<span class="comment">//每隔1s执行一次Checkpoint</span></span><br><span class="line">        env.setStateBackend(<span class="keyword">new</span> <span class="title class_">FsStateBackend</span>(<span class="string">&quot;file:///D:/ckp&quot;</span>));</span><br><span class="line">        env.getCheckpointConfig().enableExternalizedCheckpoints(CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line">        env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">        <span class="comment">//固定延迟重启策略: 程序出现异常的时候，重启2次，每次延迟3秒钟重启，超过2次，程序退出</span></span><br><span class="line">        env.setRestartStrategy(RestartStrategies.fixedDelayRestart(<span class="number">2</span>, <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.Source</span></span><br><span class="line">        DataStreamSource&lt;String&gt; sourceData = env.addSource(<span class="keyword">new</span> <span class="title class_">MyKafkaSource</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.Transformation</span></span><br><span class="line">        <span class="comment">//4.Sink</span></span><br><span class="line">        sourceData.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.execute</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MyKafkaSource就是模拟的FlinkKafkaConsumer并维护offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyKafkaSource</span> <span class="keyword">extends</span> <span class="title class_">RichParallelSourceFunction</span>&lt;String&gt; <span class="keyword">implements</span> <span class="title class_">CheckpointedFunction</span> &#123;</span><br><span class="line">        <span class="comment">//-1.声明一个OperatorState来记录offset</span></span><br><span class="line">        <span class="keyword">private</span> ListState&lt;Long&gt; offsetState = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//-2.创建状态描述器</span></span><br><span class="line">            <span class="type">ListStateDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>(<span class="string">&quot;offsetState&quot;</span>, Long.class);</span><br><span class="line">            <span class="comment">//-3.根据状态描述器初始化状态</span></span><br><span class="line">            offsetState = context.getOperatorStateStore().getListState(descriptor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function